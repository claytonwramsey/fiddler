/*
  Fiddler, a UCI-compatible chess engine.
  Copyright (C) 2022 Clayton Ramsey.

  Fiddler is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Fiddler is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//! Piece-Square Tables (PSTs).
//!
//! A PST is a table with an item for each piece at each square.
//! It grants a fixed value to the evaluation of a position for each piece, granting benefits for
//! being on "good" squares and penalties for pieces on "bad" ones.
//! For instance, a knight is much more valuable near the center, so the PST value for a knight on
//! rank 4 and file 3 is positive.

use std::intrinsics::transmute;

use crate::base::{game::Game, Color, Move, Piece, Square};

use crate::engine::evaluate::Score;

/// A lookup table for piece values.
/// The outer index is the type of the piece (in order of Pawn, Knight, Bishop, Rook, Queen, and
/// King) and the inner index is the square of the piece (from White's point of view), starting with
/// A1 as the first index, then continuing on to B1, C1, and so on until H8 as index 63.
type Pst = [[Score; 64]; Piece::NUM];

#[must_use]
/// Evaluate a game based on its PST value.
/// This is slow, so under most conditions it is recommended to use `value_delta()` instead if you
/// are making moves.
/// Returns a large value if the player to move has a better evaluation or a negative value if the
/// opponent has a good position.
pub fn evaluate(game: &Game) -> Score {
    let mut score = Score::DRAW;

    for pt in Piece::ALL {
        for sq in game.by_piece(pt) & game.white() {
            score += PST[pt as usize][sq as usize];
        }
        for sq in game.by_piece(pt) & game.black() {
            // Invert the square that Black is on, since positional values are flipped (as pawns
            // move the other way, etc)
            let alt_sq = sq.opposite();
            score -= PST[pt as usize][alt_sq as usize];
        }
    }

    match game.meta().player {
        Color::White => score,
        Color::Black => -score,
    }
}

#[must_use]
/// Get the difference in PST value which would be generated by making the move `m` on `game`.
/// `pst_delta` will reflect how the position improves for the player making the move, independent
/// of whether the player is white or black.
///
/// # Panics
///
/// This function will panic if the given move is invalid.
pub fn delta(game: &Game, m: Move) -> Score {
    let orig = m.origin();
    let dest = m.destination();
    let (mover_type, _) = game[m.origin()].unwrap();
    let mover_idx = mover_type as usize;
    let end_type = match m.promote_type() {
        Some(pt) => pt,
        None => mover_type,
    };
    let end_idx = end_type as usize;
    let (from_alt, to_alt) = match game.meta().player {
        Color::White => (orig, dest),
        Color::Black => (orig.opposite(), dest.opposite()),
    };
    let (from_idx, to_idx) = (from_alt as usize, to_alt as usize);

    // you always lose the value of the square you moved from
    let mut delta = PST[end_idx][to_idx] - PST[mover_idx][from_idx];

    if game.by_color(!game.meta().player).contains(m.destination()) {
        // conventional capture
        let to_opposite_idx = to_alt.opposite() as usize;
        let capturee_idx = game[dest].unwrap().0 as usize;
        delta += PST[capturee_idx][to_opposite_idx];
    }

    if m.is_en_passant() {
        let to_opposite_idx = (to_alt - Color::White.pawn_direction()).opposite() as usize;
        delta += PST[Piece::Pawn as usize][to_opposite_idx];
    }

    if m.is_castle() {
        let is_queen_castle = dest.file() == 2;
        let (rook_from_idx, rook_to_idx) = if is_queen_castle {
            (Square::A1 as usize, Square::D1 as usize)
        } else {
            (Square::H1 as usize, Square::F1 as usize)
        };

        delta += PST[Piece::Rook as usize][rook_to_idx] - PST[Piece::Rook as usize][rook_from_idx];
    }

    delta
}

#[rustfmt::skip] // rustfmt likes to throw a million newlines in this
/// The main piece-square table. 
/// Evaluations are paired together as (midgame, endgame) to improve cache-friendliness. 
/// The indexing order of this table has its primary index as pieces, the secondary index as 
/// squares, and the innermost index as 0 for midgame and 1 for endgame.
pub const PST: Pst = unsafe { transmute([
    [ // N
        (-8i16,-10i16), (   0,  -14), ( -35,   -8), ( -11,    1), (   0,    0), ( -21,   -5), (   0,   -6), ( -55,  -27), 
        ( -55,  -46), ( -42,  -26), ( -16,   -8), (   3,    2), (   4,    5), ( -10,  -32), ( -27,  -28), (  -9,  -50), 
        ( -15,   -9), ( -13,   -9), (   0,    0), (   5,    8), (   8,    0), (  10,   -1), (   5,  -10), ( -12,  -23), 
        ( -13,   -3), ( -17,   -6), (   2,    4), (   2,    7), (   7,    5), (   0,    7), (  18,   -1), (   0,  -12), 
        (  -2,    2), (   5,    6), (   9,   13), (  26,   10), (  13,    9), (  32,   11), (   3,    3), (   8,    0), 
        ( -35,   -5), (  15,    0), (   3,   15), (  24,    1), (  36,    0), (  32,    0), (  33,  -14), (   0,  -26), 
        ( -28,   -7), ( -16,    6), (  24,  -13), (  -6,    4), (   0,  -10), (   7,  -18), (  -2,  -12), ( -20,  -28), 
        ( -96,  -25), ( -50,  -32), ( -38,    5), ( -27,   -4), (   6,   -6), ( -70,  -15), ( -35,  -37), ( -90,  -36), 
    ],
    [ // B
        (  -1,   -1), (   0,  -12), (   0,   -1), ( -11,    0), (  -8,   -4), ( -10,   -2), ( -27,   -4), ( -33,    0), 
        ( -50,  -22), (   0,  -11), (  -8,   -5), (  -4,    2), (   2,    3), (   0,  -12), (  16,  -18), ( -34,  -15), 
        ( -13,   -9), (   0,   -8), (   6,    0), (   3,    5), (   1,    3), (   7,    1), (   0,   -7), ( -13,  -17), 
        ( -11,   -5), (  -9,  -10), (   1,    1), (   8,    2), (   5,   -7), (  -3,    0), (  -2,  -15), (   5,   -9), 
        ( -17,    5), (   0,    3), (  -4,    6), (  12,    5), (  15,    0), (  11,    3), (  -4,    0), (  -5,    0), 
        ( -21,    0), (   0,   -3), (   7,    0), (   6,   -5), (   9,   -6), (  17,    0), (  10,   -6), ( -13,    1), 
        ( -14,   -5), ( -12,    3), ( -20,    9), ( -34,  -17), ( -17,    0), (  18,   -9), (   2,  -10), ( -44,  -15), 
        ( -26,  -14), ( -21,  -14), ( -50,  -17), ( -34,    2), ( -28,   -4), ( -61,   -4), ( -28,  -11), ( -10,  -30), 
    ],
    [ // R
        (   0,    0), (   0,   -4), (   0,    0), (   1,   -1), (   2,   -4), (   6,   -8), ( -16,   -3), ( -16,   -6), 
        ( -20,  -24), ( -11,  -15), (  -6,   -7), (   0,    0), (   1,   -6), (   0,  -18), (   2,  -27), ( -29,  -23), 
        ( -22,  -12), ( -22,   -8), ( -12,   -6), (  -5,   -6), (  -4,  -11), (  -3,  -12), (  -1,  -19), ( -24,  -26), 
        ( -18,  -12), ( -21,   -1), (  -6,   -2), (   0,   -6), (   0,   -9), ( -12,  -10), (   0,  -13), (  -7,  -21), 
        ( -10,   -8), ( -21,  -11), (   0,    0), (  -5,   -7), (  -7,  -10), (   6,  -13), ( -12,  -17), (  -9,  -18), 
        (  -7,   -3), (   0,    0), (   0,   -3), (   3,    0), (   0,   -2), (  24,  -14), (  17,  -11), (   2,  -13), 
        (   3,    2), (   6,    6), (  25,    8), (  27,    3), (  20,   -5), (  39,    0), (  25,   -4), (   1,   -6), 
        (  -2,    7), (  16,    0), (  10,    3), (  23,    0), (  26,    0), (   0,    0), (   0,  -11), (  -1,    0), 
    ],
    [ // Q
        (  -8,   -9), ( -18,    0), (  -8,   -1), (   3,   -6), ( -10,    0), ( -22,    0), (  -8,   -2), ( -32,   -1), 
        ( -38,   -5), ( -38,    1), (  -4,    7), (  -2,    0), (   6,    0), (  -1,   -4), ( -13,   -1), (   3,  -24), 
        ( -24,   -6), (  -5,    0), (  -8,    1), (   0,    5), (  -3,    9), (   8,   -1), (   0,   -1), (  11,  -10), 
        ( -18,    0), ( -22,    7), (  -6,    2), (  -3,   11), (   0,   19), (   0,    8), (   0,    0), (   0,   -3), 
        ( -25,   -3), ( -21,    0), ( -13,    9), (   0,   10), (  13,    3), (  17,    0), (   5,    0), (   0,   -6), 
        ( -26,   -7), ( -21,   -2), (  -4,   -1), (   8,    9), (  35,   -4), (  38,   -6), (  46,  -12), (  28,  -26), 
        ( -43,   -4), ( -35,    4), (   2,    2), (  15,    6), (   7,    0), (  32,   -7), (  29,  -13), (  14,  -23), 
        ( -28,  -14), (   0,    2), (  10,    1), (   0,    5), (  36,    0), (   8,   -6), (  17,   -9), (  23,  -22), 
    ],
    [ // P
        (   1,    2), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), 
        (  -7,    0), (   4,    2), ( -15,    0), ( -11,    2), (   0,    8), (  13,    0), (  20,    2), ( -10,   -3), 
        (  -7,   -8), (  -4,    1), (  -4,   -5), (  -5,    0), (   0,   -1), (   0,   -6), (   6,   -1), (  -3,  -13), 
        (  -8,    3), (  -2,    9), (   0,    0), (   9,   -5), (   9,   -4), (  -1,   -4), (  -3,    1), ( -13,   -9), 
        (  -2,   22), (  10,   19), (   1,    9), (  15,    4), (   9,    0), (   6,    3), (   7,   10), (  -9,    7), 
        (  12,   63), (  31,   69), (  28,   52), (  37,   49), (  48,   26), (  43,   32), (  34,   50), (  10,   48), 
        (  15,  116), (  24,  110), (  44,  100), (  77,  104), (  97,  101), (  57,   52), (  34,   66), (  -1,  107), 
        (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), (   0,    0), 
    ],
    [ // K
        (   0,   -1), (   8,  -25), (   3,  -13), ( -22,  -16), ( -10,  -13), ( -22,   -3), (  19,  -16), ( -28,  -10), 
        (  -7,  -17), (  13,  -25), (   9,  -18), ( -14,  -12), (   0,   -7), (   0,   -9), (  24,  -18), (  -4,   -6), 
        ( -10,  -14), (  18,  -21), (   9,   -7), (   0,   -3), (  -6,    0), (  -1,    0), (   1,   -4), ( -16,   -2), 
        ( -30,  -12), (   7,  -17), (   8,    0), (  -3,    2), (  -7,    3), (  -1,    2), ( -18,   -6), ( -41,   -1), 
        ( -23,    0), (  21,    2), (  18,    3), (   0,    6), (   0,    5), (  15,    6), (  12,    5), (  -7,    4), 
        (   3,    4), (  28,    0), (  36,    4), (   8,    0), (  12,    0), (  40,   16), (  32,   11), (   3,   21), 
        (   0,   -8), (  22,    5), (  14,    0), (  14,    0), (  17,    0), (  24,    9), (  25,    3), (  21,    4), 
        ( -30,  -33), (  -1,  -32), (  -5,  -17), ( -26,   -4), ( -20,    1), ( -16,   12), (  28,    6), (   0,   -9), 
    ],
]) };

#[cfg(test)]
mod tests {

    use super::*;
    use crate::base::movegen::{make_move_vec, GenMode};

    /// Helper function to verify that the implementation of [`delta`] is correct.
    ///
    /// For each move reachable from a game with start position `fen`, this will assert that the
    /// result of [`evaluate`] is equal to the sum of the original evaluation and the computed
    /// delta for the move.
    fn delta_helper(fen: &str) {
        let mut game = Game::from_fen(fen).unwrap();
        let orig_eval = evaluate(&game);
        for m in make_move_vec::<{ GenMode::All }>(&game) {
            let d = delta(&game, m);
            println!("m {m}, orig {orig_eval}, delta {d}");
            let new_eval = -d - orig_eval;
            game.make_move(m);
            assert_eq!(evaluate(&game), new_eval);
            game.undo().unwrap();
        }
    }

    #[test]
    /// Test that adding deltas matches the same result as taking the PST value from scratch.
    fn pst_delta_equals_base_result() {
        delta_helper("r1bq1b1r/ppp2kpp/2n5/3np3/2B5/8/PPPP1PPP/RNBQK2R w KQ - 0 7");
    }

    #[test]
    fn delta_captures() {
        delta_helper("r1bq1b1r/ppp2kpp/2n5/3n4/2BPp3/2P5/PP3PPP/RNBQK2R b KQ d3 0 8");
    }

    #[test]
    fn delta_promotion() {
        delta_helper("r4bkr/pPpq2pp/2n1b3/3n4/2BPp3/2P5/1P3PPP/RNBQK2R w KQ - 1 13");
    }
}
