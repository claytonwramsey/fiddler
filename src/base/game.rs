/*
  Fiddler, a UCI-compatible chess engine.
  Copyright (C) 2022 Clayton Ramsey.

  Fiddler is free software: you can redistribute it and/or modify
  it under the terms of the GNU General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

  Fiddler is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  GNU General Public License for more details.

  You should have received a copy of the GNU General Public License
  along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//! Full chess games, including history and metadata.

use super::movegen::is_legal;

use super::{
    movegen::{get_moves, has_moves, GenMode},
    Board, Move,
};

use nohash_hasher::IntMap;

use std::{
    default::Default,
    fmt::{Display, Formatter},
};

#[allow(clippy::module_name_repetitions)]
#[derive(Clone, Debug, Eq, PartialEq)]
/// A struct containing game information, which unlike a [`Board`], knows about its history and can
/// do things like repetition detection.
///
/// `C` is a *cookie*: it is a set of data which is useless for the internal behavior of a game,
/// but which the consumer of a [`CookieGame`] may use to their benefit.
/// For each board state in the history of this game, a cookie is stored which is associated with
/// that board.
pub struct CookieGame<C: Sized> {
    /// The last element in `history` is the current state of the board.
    /// The first element should be the starting position of the game, and in between are sequential
    /// board states from the entire game.
    history: Vec<(Board, C)>,
    /// The list, in order, of all moves made in the game.
    /// They should all be valid moves.
    /// The length of `moves` should always be one less than the length of `history`.
    moves: Vec<Move>,
    /// Stores the number of times a position has been reached in the course of this game.
    /// It is used for three-move-rule draws.
    /// The keys are the Zobrist hashes of the boards previously visited.
    ///
    /// The values are a tuple of two integers: the first is the total number of repetitions, and
    /// the second is the number of repetitions since the last search start.
    repetitions: IntMap<u64, (u8, u8)>,
    /// Whether this game is currently part of a search.
    /// If it is, then the search-level repetitions will be incremented and result in draws.
    searching: bool,
}

/// A useful type alias for a game which does not store any cookie information on its history.
pub type Game = CookieGame<()>;

impl<Cookie: Sized> CookieGame<Cookie> {
    #[must_use]
    /// Construct a new [`Game`] in the conventional chess starting position.
    pub fn new(b: Board, c: Cookie) -> CookieGame<Cookie> {
        CookieGame {
            history: vec![(b, c)],
            moves: Vec::new(),
            repetitions: IntMap::from_iter([(b.hash, (1, 0))]),
            searching: false,
        }
    }

    /// Empty out the history of this game completely, but leave the original start state of the
    /// board.
    /// Will also end the searching period for the game.
    pub fn clear(&mut self) {
        self.history.truncate(1);
        let start_board = self.history[0].0;
        self.moves.clear();
        self.repetitions.clear();
        // since we cleared this, or_insert will always be called
        self.repetitions.insert(start_board.hash, (1, 0));
        self.searching = false;
    }

    /// Make a move, assuming said move is legal.
    ///
    /// `tag` should have been generated by `T::tag_move(m)`.
    ///
    /// # Panics
    ///
    /// This function may panic if `m` is not a legal move.
    /// However, it is not guaranteed to.
    /// It is recommended to only call `make_move` with moves that were already validated.
    pub fn make_move(&mut self, m: Move, cookie: Cookie) {
        /*
        #[cfg(debug_assertions)]
        if !is_legal(m, self.board()) {
            println!("an illegal move {m} is being attempted. History: {self}");
            panic!();
        }
        */
        let previous_state = self.history.last().unwrap();
        let mut new_board = previous_state.0;

        new_board.make_move(m);
        let num_reps = self.repetitions.entry(new_board.hash).or_insert((0, 0));
        num_reps.0 += 1;
        if self.searching {
            num_reps.1 += 1;
        }
        self.history.push((new_board, cookie));
        self.moves.push(m);
    }

    #[allow(clippy::result_unit_err)]
    /// Attempt to play a move, which may or may not be legal.
    /// Will return `Ok(())` if `m` was a legal move.
    ///
    /// # Errors
    ///
    /// This function will return an `Err(())` if the move is illegal.
    pub fn try_move(&mut self, m: Move, cookie: Cookie) -> Result<(), ()> {
        if is_legal(m, self.board()) {
            self.make_move(m, cookie);
            Ok(())
        } else {
            Err(())
        }
    }

    /// Undo the most recent move.
    /// This function will return `Ok()` if there was history to undo.
    /// The move inside the `Ok` variant will be the most recent move played.
    ///
    /// # Errors
    ///
    /// This function will return an `Err` if the history of this game has no more positions left
    /// to undo.
    pub fn undo(&mut self) -> Result<Move, &'static str> {
        let m_removed = self.moves.pop().ok_or("no moves to remove")?;
        let b_removed = self.history.pop().ok_or("no boards in history")?.0;
        let num_reps = self
            .repetitions
            .entry(b_removed.hash)
            .or_insert((1, u8::from(self.searching)));
        num_reps.0 -= 1;
        if self.searching && num_reps.1 > 0 {
            num_reps.1 -= 1;
        }
        if num_reps.0 == 0 {
            self.repetitions.remove(&b_removed.hash);
        }

        Ok(m_removed)
    }

    #[must_use]
    #[allow(clippy::missing_panics_doc)]
    /// Get the position representing the current state of the game.
    pub fn board(&self) -> &Board {
        &self.history.last().unwrap().0
    }

    #[must_use]
    #[allow(clippy::missing_panics_doc)]
    /// Get the cookie of the current state of the game.
    pub fn cookie(&self) -> &Cookie {
        &self.history.last().unwrap().1
    }

    #[must_use]
    /// Detect how the game has ended.
    ///
    /// There are three possible return values:
    /// * `None`: the game is not over.
    /// * `Some(false)`: the game is over and is drawn.
    /// * `Some(true)`: the game is over by checkmate.
    pub fn end_state(&self) -> Option<bool> {
        let b = self.board();
        if self.drawn_by_repetition() || b.is_drawn() {
            return Some(false);
        }

        if has_moves(b) {
            return None;
        }

        Some(!b.checkers.is_empty())
    }

    #[must_use]
    /// Determine whether this game been drawn due to history (i.e. repetition or the 50 move rule).
    pub fn drawn_by_repetition(&self) -> bool {
        let num_reps = self.repetitions.get(&self.board().hash).unwrap_or(&(0, 0));
        if num_reps.0 >= 3 || num_reps.1 >= 2 {
            // draw by repetition
            return true;
        }

        false
    }

    /// Get the legal moves in this position.
    ///
    /// Will return an empty vector if there are no legal moves.
    pub fn get_moves<const M: GenMode>(&self, callback: impl FnMut(Move)) {
        if !self.drawn_by_repetition() {
            get_moves::<M>(self.board(), callback);
        }
    }

    #[allow(clippy::len_without_is_empty)]
    #[must_use]
    /// Get the number of total positions in this history of this game.
    pub fn len(&self) -> usize {
        self.history.len()
    }

    /// Begin searching.
    /// During a search, repetitions of positions that were seen as the search went on will be
    /// immediately marked as draws.
    /// The current position of the board will also be marked as a possible repetition.
    ///
    /// # Examples
    ///
    /// In the following example, `g1` is not over because a position must be reached 3 times to
    /// reach a draw.
    /// However, `g2` is over because it repeated the same position twice in a search.
    ///
    /// ```
    /// use fiddler::base::{game::Game, Move, Square};
    ///
    /// let mut g1 = Game::default();
    /// let mut g2 = Game::default();
    /// g2.start_search();
    ///
    /// let moves = [
    ///     Move::normal(Square::B1, Square::C3),
    ///     Move::normal(Square::B8, Square::C6),
    ///     Move::normal(Square::C3, Square::B1),
    ///     Move::normal(Square::C6, Square::B8),
    /// ];
    ///
    /// for m in moves {
    ///     g1.make_move(m, ());
    ///     g2.make_move(m, ());
    /// }
    ///
    /// assert!(!g1.end_state().is_some());
    /// assert!(g2.end_state().is_some());
    /// ```
    pub fn start_search(&mut self) {
        self.searching = true;
        for val in self.repetitions.values_mut() {
            val.1 = 0;
        }
        // mark the current position as visited during search
        self.repetitions
            .entry(self.board().hash)
            .and_modify(|v| v.1 = 1);
    }

    /// Stop performing a search.
    ///
    /// This will result in repetitions being counted at 3 once more.
    pub fn stop_search(&mut self) {
        self.searching = false;
    }
}

impl<Cookie: Sized + Default> Default for CookieGame<Cookie> {
    fn default() -> Self {
        CookieGame::new(Board::default(), Cookie::default())
    }
}

impl<C: Sized> Display for CookieGame<C> {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        for i in 0..self.moves.len() {
            let board = &self.history[i].0;
            let m = self.moves[i];
            write!(f, "{} ", m.to_algebraic(board).unwrap())?;
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::base::{Board, Move, Square};

    #[test]
    /// Test that we can play a simple move on a [`Game`] and have the board  states update
    /// accordingly.
    fn play_e4() {
        let mut g = Game::default();
        let m = Move::normal(Square::E2, Square::E4);
        let mut old_board = *g.board();
        g.make_move(m, ());
        let new_board = g.board();

        old_board.make_move(m);
        assert_eq!(old_board, *new_board);
    }

    #[test]
    /// Test that a single move can be undone correctly.
    fn undo_move() {
        let mut g = Game::default();
        let m = Move::normal(Square::E2, Square::E4);
        g.make_move(m, ());
        assert_eq!(g.undo(), Ok(m));
        assert_eq!(*g.board(), Board::default());
    }

    #[test]
    /// Test that an undo will fail if there is no history to undo.
    fn illegal_undo() {
        let mut g = Game::default();
        assert!(g.undo().is_err());
        assert_eq!(*g.board(), Board::default());
    }

    #[test]
    /// Test that we can undo multiple moves in a row.
    fn undo_multiple_moves() {
        let mut g = Game::default();
        let m0 = Move::normal(Square::E2, Square::E4);
        let m1 = Move::normal(Square::E7, Square::E5);
        g.make_move(m0, ());
        g.make_move(m1, ());
        g.undo().unwrap();
        g.undo().unwrap();
        assert_eq!(*g.board(), Board::default());
    }

    #[test]
    /// Test that a [`Game`] becomes exactly the same as what it started as if a move is undone.
    fn undo_equality() {
        let mut g = Game::default();
        g.make_move(Move::normal(Square::E2, Square::E4), ());
        assert!(g.undo().is_ok());
        assert_eq!(g, Game::default());
    }

    #[test]
    /// Test that undoing a move results in the previous position.
    fn undo_fried_liver() {
        // the fried liver FEN
        let fen = "r1bq1b1r/ppp2kpp/2n5/3np3/2B5/8/PPPP1PPP/RNBQK2R w KQ - 0 7";
        let mut g = Game::new(Board::from_fen(fen).unwrap(), ());
        let m = Move::normal(Square::D1, Square::F3);
        g.make_move(m, ());
        assert_eq!(g.undo(), Ok(m));
        assert_eq!(g, Game::new(Board::from_fen(fen).unwrap(), ()));
        assert_eq!(g.board(), &Board::from_fen(fen).unwrap());
    }

    #[test]
    /// Test that undoing with no history results in an error.
    fn undo_fail() {
        let mut g = Game::default();
        assert!(g.undo().is_err());
    }

    #[test]
    /// Test that a mated position is in fact over.
    fn is_mate_over() {
        // the position from the end of Scholar's mate
        let g = Game::new(
            Board::from_fen("rnbqk2r/pppp1Qpp/5n2/2b1p3/2B1P3/8/PPPP1PPP/RNB1K1NR b KQkq - 0 4")
                .unwrap(),
            (),
        );

        g.get_moves::<{ GenMode::All }>(|m| panic!("{m:?}"));
        assert!(!has_moves(g.board()));
        assert_eq!(g.end_state(), Some(true));
    }

    #[test]
    fn is_mate_over_2() {
        let g = Game::new(
            Board::from_fen("r1b2b1r/ppp2kpp/8/4p3/3n4/2Q5/PP1PqPPP/RNB1K2R w KQ - 4 11").unwrap(),
            (),
        );

        g.get_moves::<{ GenMode::All }>(|m| panic!("{m:?}"));
        assert!(!has_moves(g.board()));
        assert_eq!(g.end_state(), Some(true));
    }

    #[test]
    fn startpos_not_over() {
        assert!(Game::default().end_state().is_none());
    }

    #[test]
    /// Test that clearing a board has the same effect of replacing it with a default board if the
    /// initial state was the initial board state.
    fn clear_board() {
        let mut g = Game::default();
        g.make_move(Move::normal(Square::E2, Square::E4), ());
        g.clear();
        assert_eq!(g, Game::default());
    }
}
